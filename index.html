const x1 = rect1.left - boardRect.left + rect1.width / 2;
               const y1 = rect1.top - boardRect.top + rect1.height / 2;
               const x2 = rect2.left - boardRect.left + rect2.width / 2;
               const y2 = rect2.top - boardRect.top + rect2.height / 2;
               
               const line = document.createElement('div');
               line.className = 'chain-line';
               
               const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
               const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
               
               line.style.width = length + 'px';
               line.style.left = x1 + 'px';
               line.style.top = y1 + 'px';
               line.style.transform = `rotate(${angle}deg)`;
               line.style.transformOrigin = '0 50%';
               
               document.getElementById('gameBoard').appendChild(line);
           }
       }

       function clearChainLines() {
           document.querySelectorAll('.chain-line').forEach(line => line.remove());
       }

       // ãƒã‚¤ãƒ³ãƒˆè¨ˆç®—
       function calculatePoints() {
           let basePoints = selectedTsums.length * 120;
           let specialBonus = selectedTsums.filter(t => t.dataset.special === 'true').length * 600;
           let comboMultiplier = Math.floor(combo / 3) + 1;
           let chainBonus = selectedTsums.length > 6 ? selectedTsums.length * 80 : 0;
           let levelBonus = level * 50;
           
           return (basePoints + specialBonus + chainBonus + levelBonus) * comboMultiplier;
       }

       // ã‚¹ã‚³ã‚¢è¿½åŠ 
       function addScore(points) {
           score += points;
           updateScore();
           showFloatingScore(points);
       }

       function showFloatingScore(points) {
           const floating = document.createElement('div');
           floating.className = 'floating-score';
           floating.textContent = `+${points}`;
           floating.style.left = Math.random() * 200 + 100 + 'px';
           floating.style.top = '50%';
           
           document.getElementById('gameBoard').appendChild(floating);
           setTimeout(() => floating.remove(), 1000);
       }

       // ãƒ„ãƒ æ¶ˆåŽ»
       function eliminateTsums() {
           selectedTsums.forEach((tsum, index) => {
               setTimeout(() => {
                   if (tsum.parentNode) {
                       tsum.classList.add('eliminating');
                       setTimeout(() => {
                           if (tsum.parentNode) {
                               const newColor = colors[Math.floor(Math.random() * Math.min(5 + level, colors.length))];
                               const isSpecial = Math.random() < 0.06 + (level * 0.015);
                               
                               tsum.className = `tsum ${newColor}${isSpecial ? ' special' : ''} spawning`;
                               tsum.textContent = isSpecial ? 'ðŸ’Ž' : colorEmojis[newColor];
                               tsum.dataset.color = newColor;
                               tsum.dataset.special = isSpecial;
                               
                               setTimeout(() => tsum.classList.remove('spawning'), 400);
                           }
                       }, 300);
                   }
               }, index * 60);
           });
       }

       // é¸æŠžã‚¯ãƒªã‚¢
       function clearSelection() {
           selectedTsums.forEach(tsum => {
               if (tsum.parentNode) {
                   tsum.classList.remove('selected');
               }
           });
           selectedTsums = [];
           chainCount = 0;
       }

       // UIæ›´æ–°
       function updateScore() {
           document.getElementById('score').textContent = score.toLocaleString();
       }

       function updateCombo() {
           if (selectedTsums.length >= 3) {
               combo++;
           }
           document.getElementById('combo').textContent = combo;
       }

       function updateTimer() {
           document.getElementById('timer').textContent = timeLeft;
           
           const timerDisplay = document.getElementById('timerDisplay');
           if (timeLeft <= 10) {
               timerDisplay.classList.add('urgent');
           } else {
               timerDisplay.classList.remove('urgent');
           }
           
           if (timeLeft <= 0) {
               endGame();
           } else {
               timeLeft--;
           }
       }

       function updateChainDisplay() {
           const chainCounter = document.getElementById('chainCounter');
           if (chainCount > 0) {
               chainCounter.style.display = 'block';
               document.getElementById('chainCount').textContent = chainCount;
           }
       }

       function updatePowerUps() {
           document.getElementById('bombCount').textContent = powerUps.bomb;
           document.getElementById('rainbowCount').textContent = powerUps.rainbow;
           document.getElementById('timeCount').textContent = powerUps.time;
           
           document.getElementById('bombPower').classList.toggle('disabled', powerUps.bomb <= 0);
           document.getElementById('rainbowPower').classList.toggle('disabled', powerUps.rainbow <= 0);
           document.getElementById('timePower').classList.toggle('disabled', powerUps.time <= 0);
       }

       // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—
       function levelUp() {
           level++;
           timeLeft += 12;
           showNotification(`ðŸŽ‰ ãƒ¬ãƒ™ãƒ« ${level}ï¼ +12ç§’ãƒœãƒ¼ãƒŠã‚¹ï¼`);
           document.getElementById('level').textContent = level;
           
           powerUps.bomb += 1;
           if (level % 2 === 0) powerUps.rainbow += 1;
           if (level % 3 === 0) powerUps.time += 1;
           
           updatePowerUps();
           
           // å¼·åŠ›ãªæŒ¯å‹•
           if (navigator.vibrate) {
               navigator.vibrate([200, 100, 200, 100, 200]);
           }
       }

       // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ä½¿ç”¨
       function usePowerUp(type) {
           if (!gameRunning || powerUps[type] <= 0) return;
           
           powerUps[type]--;
           updatePowerUps();
           
           if (navigator.vibrate) {
               navigator.vibrate(120);
           }
           
           switch(type) {
               case 'bomb':
                   const randomTsums = [...tsums].sort(() => Math.random() - 0.5).slice(0, 15);
                   randomTsums.forEach((tsum, index) => {
                       setTimeout(() => {
                           if (tsum.parentNode) {
                               tsum.classList.add('eliminating');
                               setTimeout(() => {
                                   if (tsum.parentNode) {
                                       const newColor = colors[Math.floor(Math.random() * colors.length)];
                                       const isSpecial = Math.random() < 0.1;
                                       
                                       tsum.className = `tsum ${newColor}${isSpecial ? ' special' : ''} spawning`;
                                       tsum.textContent = isSpecial ? 'ðŸ’Ž' : colorEmojis[newColor];
                                       tsum.dataset.color = newColor;
                                       tsum.dataset.special = isSpecial;
                                       
                                       setTimeout(() => tsum.classList.remove('spawning'), 400);
                                   }
                               }, 300);
                           }
                       }, index * 40);
                   });
                   addScore(1500);
                   showNotification('ðŸ’£ ãƒœãƒ çˆ†ç™ºï¼');
                   break;
                   
               case 'rainbow':
                   const dominantColor = colors[Math.floor(Math.random() * colors.length)];
                   tsums.forEach((tsum, index) => {
                       if (Math.random() < 0.4) {
                           setTimeout(() => {
                               tsum.dataset.color = dominantColor;
                               tsum.className = `tsum ${dominantColor}`;
                               tsum.textContent = colorEmojis[dominantColor];
                               tsum.style.transform = 'scale(1.2)';
                               setTimeout(() => {
                                   tsum.style.transform = '';
                               }, 200);
                           }, index * 20);
                       }
                   });
                   showNotification('ðŸŒˆ ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ç™ºå‹•ï¼');
                   break;
                   
               case 'time':
                   timeLeft += 25;
                   showNotification('â° +25ç§’è¿½åŠ ï¼');
                   break;
           }
       }

       // å®Ÿç¸¾ãƒã‚§ãƒƒã‚¯
       function checkAchievements() {
           const newAchievements = [];
           
           if (!achievements.has('firstPlay') && score > 0) {
               newAchievements.push('firstPlay');
           }
           if (!achievements.has('score1000') && score >= 1000) {
               newAchievements.push('score1000');
           }
           if (!achievements.has('score5000') && score >= 5000) {
               newAchievements.push('score5000');
           }
           if (!achievements.has('combo10') && combo >= 10) {
               newAchievements.push('combo10');
           }
           if (!achievements.has('speedDemon') && (Date.now() - gameStartTime) < 25000 && score >= 3000) {
               newAchievements.push('speedDemon');
           }
           if (!achievements.has('perfectGame') && perfectGame && score >= 4000) {
               newAchievements.push('perfectGame');
           }
           
           newAchievements.forEach(achievementId => {
               achievements.add(achievementId);
               const achievement = achievementList.find(a => a.id === achievementId);
               if (achievement) {
                   showAchievement(achievement);
                   showNotification(`ðŸ† ${achievement.icon} ${achievement.name} é”æˆï¼`);
               }
           });
           
           saveAchievements();
       }

       function showAchievement(achievement) {
           const elem = document.createElement('div');
           elem.className = 'achievement';
           elem.textContent = `${achievement.icon} ${achievement.name}`;
           
           document.getElementById('achievementDisplay').appendChild(elem);
           
           setTimeout(() => elem.classList.add('show'), 100);
           setTimeout(() => {
               elem.style.opacity = '0';
               setTimeout(() => elem.remove(), 300);
           }, 3000);
       }

       // é€šçŸ¥è¡¨ç¤º
       function showNotification(message) {
           const notification = document.createElement('div');
           notification.className = 'notification';
           notification.textContent = message;
           document.body.appendChild(notification);
           setTimeout(() => notification.remove(), 2000);
       }

       // ã‚²ãƒ¼ãƒ é–‹å§‹
       function startGame() {
           gameRunning = true;
           gameStartTime = Date.now();
           score = 0;
           timeLeft = 60;
           combo = 0;
           level = 1;
           perfectGame = true;
           
           updateScore();
           updateTimer();
           updateCombo();
           updatePowerUps();
           
           document.getElementById('level').textContent = level;
           document.getElementById('startBtn').textContent = 'å®Ÿè¡Œä¸­';
           document.getElementById('startBtn').style.opacity = '0.5';
           
           initializeBoard();
           
           gameTimer = setInterval(updateTimer, 1000);
           
           // ãƒ©ãƒ³ãƒ€ãƒ ã‚¤ãƒ™ãƒ³ãƒˆé–‹å§‹
           setTimeout(randomEvent, Math.random() * 15000 + 8000);
           
           showNotification('ðŸš€ ã‚²ãƒ¼ãƒ é–‹å§‹ï¼é€£éŽ–ã‚’ç‹™ãˆï¼');
           
           if (navigator.vibrate) {
               navigator.vibrate([100, 50, 100]);
           }
       }

       // ãƒ©ãƒ³ãƒ€ãƒ ã‚¤ãƒ™ãƒ³ãƒˆ
       function randomEvent() {
           if (!gameRunning) return;
           
           const events = [
               () => {
                   timeLeft += 8;
                   showNotification('ðŸŽ æ™‚é–“ãƒœãƒ¼ãƒŠã‚¹ï¼+8ç§’');
               },
               () => {
                   powerUps.bomb += 2;
                   updatePowerUps();
                   showNotification('ðŸ’£ ãƒœãƒ Ã—2 ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆï¼');
               },
               () => {
                   const specialCount = Math.floor(Math.random() * 8) + 5;
                   const randomTsums = [...tsums].sort(() => Math.random() - 0.5).slice(0, specialCount);
                   randomTsums.forEach(tsum => {
                       tsum.dataset.special = 'true';
                       tsum.classList.add('special');
                       tsum.textContent = 'ðŸ’Ž';
                   });
                   showNotification('âœ¨ ç‰¹æ®Šãƒ„ãƒ å¤§ç™ºç”Ÿï¼');
               },
               () => {
                   const bonusScore = Math.floor(Math.random() * 1200) + 600;
                   addScore(bonusScore);
                   showNotification(`ðŸŒŸ ãƒ©ãƒƒã‚­ãƒ¼ï¼+${bonusScore}ç‚¹ï¼`);
               }
           ];
           
           const randomEventFunc = events[Math.floor(Math.random() * events.length)];
           randomEventFunc();
           
           // æ¬¡ã®ã‚¤ãƒ™ãƒ³ãƒˆäºˆç´„
           setTimeout(randomEvent, Math.random() * 20000 + 12000);
       }

       // ã‚²ãƒ¼ãƒ çµ‚äº†
       function endGame() {
           gameRunning = false;
           clearInterval(gameTimer);
           clearSelection();
           clearChainLines();
           
           document.getElementById('startBtn').textContent = 'é–‹å§‹';
           document.getElementById('startBtn').style.opacity = '1';
           
           checkAchievements();
           
           let message = `ðŸŽ® ã‚²ãƒ¼ãƒ çµ‚äº†ï¼\n\n`;
           message += `ðŸ“Š æœ€çµ‚ã‚¹ã‚³ã‚¢: ${score.toLocaleString()}ç‚¹\n`;
           message += `ðŸŽ¯ åˆ°é”ãƒ¬ãƒ™ãƒ«: ${level}\n`;
           message += `ðŸ”¥ æœ€é«˜ã‚³ãƒ³ãƒœ: ${combo}é€£éŽ–\n`;
           message += `â­ ç²å¾—å®Ÿç¸¾: ${achievements.size}å€‹\n\n`;
           
           if (score >= 5000) {
               message += `ðŸ† ç´ æ™´ã‚‰ã—ã„ã‚¹ã‚³ã‚¢ã§ã™ï¼\n`;
           } else if (score >= 2000) {
               message += `ðŸ‘ è‰¯ã„ã‚¹ã‚³ã‚¢ã§ã™ï¼\n`;
           } else {
               message += `ðŸ’ª æ¬¡å›žã¯ã‚‚ã£ã¨é ‘å¼µã‚Šã¾ã—ã‚‡ã†ï¼\n`;
           }
           
           message += `\nðŸ”„ ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦ã—ã¾ã™ã‹ï¼Ÿ`;
           
           setTimeout(() => {
               if (confirm(message)) {
                   startGame();
               }
           }, 1000);
       }

       // ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
       function resetGame() {
           gameRunning = false;
           clearInterval(gameTimer);
           score = 0;
           timeLeft = 60;
           combo = 0;
           level = 1;
           chainCount = 0;
           
           updateScore();
           updateTimer();
           updateCombo();
           clearSelection();
           clearChainLines();
           
           document.getElementById('level').textContent = level;
           document.getElementById('chainCounter').style.display = 'none';
           document.getElementById('startBtn').textContent = 'é–‹å§‹';
           document.getElementById('startBtn').style.opacity = '1';
           
           initializeBoard();
       }

       // å®Ÿç¸¾ç®¡ç†
       function loadAchievements() {
           const saved = localStorage.getItem('tsumAchievements');
           if (saved) {
               achievements = new Set(JSON.parse(saved));
           }
       }

       function saveAchievements() {
           localStorage.setItem('tsumAchievements', JSON.stringify([...achievements]));
       }

       // PWAé–¢é€£
       if ('serviceWorker' in navigator) {
           navigator.serviceWorker.register('/service-worker.js')
               .then(registration => console.log('PWA ready'))
               .catch(error => console.log('PWA failed'));
       }

       // ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
       let deferredPrompt;
       window.addEventListener('beforeinstallprompt', (e) => {
           e.preventDefault();
           deferredPrompt = e;
       });

       // ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³å¯¾å¿œ
       function toggleFullscreen() {
           if (!document.fullscreenElement) {
               document.documentElement.requestFullscreen().catch(err => {
                   console.log(`Fullscreen error: ${err.message}`);
               });
           } else {
               document.exitFullscreen();
           }
       }

       // ç”»é¢å›žè»¢å¯¾å¿œ
       window.addEventListener('orientationchange', () => {
           setTimeout(() => {
               if (gameRunning) {
                   clearChainLines();
               }
           }, 500);
       });

       // ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†åœæ­¢
       document.addEventListener('visibilitychange', () => {
           if (document.hidden && gameRunning) {
               // ã‚²ãƒ¼ãƒ ã‚’ä¸€æ™‚åœæ­¢
               clearInterval(gameTimer);
           } else if (!document.hidden && gameRunning) {
               // ã‚²ãƒ¼ãƒ ã‚’å†é–‹
               gameTimer = setInterval(updateTimer, 1000);
           }
       });

       // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼ˆé–‹ç™ºæ™‚ã®ã¿ï¼‰
       if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
           window.debugGame = {
               addScore: (points) => addScore(points),
               levelUp: () => levelUp(),
               addPowerUp: (type, count) => {
                   powerUps[type] += count;
                   updatePowerUps();
               }
           };
       }

       // é•·æŠ¼ã—é˜²æ­¢
       document.addEventListener('contextmenu', e => e.preventDefault());
       
       // æ‹¡å¤§é˜²æ­¢
       document.addEventListener('gesturestart', e => e.preventDefault());
       document.addEventListener('gesturechange', e => e.preventDefault());
       document.addEventListener('gestureend', e => e.preventDefault());
       
       // ã‚¹ãƒ¯ã‚¤ãƒ—ç„¡åŠ¹åŒ–
       let startY;
       document.addEventListener('touchstart', e => {
           startY = e.touches[0].clientY;
       });
       
       document.addEventListener('touchmove', e => {
           const y = e.touches[0].clientY;
           if (!e.target.closest('.game-board') && Math.abs(y - startY) > 10) {
               e.preventDefault();
           }
       }, { passive: false });
   </script>
</body>
</html>
